/**
 * Copyright Â© 2022-2023 Jesse Gallagher
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * HCL Domino REST API basis
 * REST APIs for Domino and more done right. With declarative security and access to Code, Design and Data
 *
 * The version of the OpenAPI document: 1.0.8
 * Contact: HeyHCL@pnp-hcl.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

package org.openntf.xsp.nosql.communication.driver.keep.client.model;

import java.lang.reflect.Type;
import java.math.BigDecimal;
import jakarta.json.bind.annotation.JsonbCreator;
import jakarta.json.bind.annotation.JsonbProperty;
import jakarta.json.bind.annotation.JsonbTypeDeserializer;
import jakarta.json.bind.annotation.JsonbTypeSerializer;
import jakarta.json.bind.serializer.DeserializationContext;
import jakarta.json.bind.serializer.JsonbDeserializer;
import jakarta.json.bind.serializer.JsonbSerializer;
import jakarta.json.bind.serializer.SerializationContext;
import jakarta.json.stream.JsonGenerator;
import jakarta.json.stream.JsonParser;
import jakarta.validation.constraints.NotNull;

/**
 * Field description for fields / items in a KeepFormMode. Describes name, type, and multi-value
 * capability. Modeled after json-schema where multi-value = array extension to json-schema limited
 * to x-access-name to specify Domino Names, Reader, Author nature All other field copied from JSON
 * Schema
 **/

public class KeepField {

  /**
   * Field name. While anything theoretical is possible we stick to letters and numbers with the
   * first letter capitalized. Not a hard rule to accomodate existing data
   **/
  @JsonbProperty("name")
  private String name;

  @JsonbTypeSerializer(TypeEnum.Serializer.class)
  @JsonbTypeDeserializer(TypeEnum.Deserializer.class)
  public enum TypeEnum {

    OBJECT(String.valueOf("object")), ARRAY(String.valueOf("array")), STRING(
        String.valueOf("string")), NUMBER(String.valueOf("number")), INTEGER(
            String.valueOf("integer")), BOOLEAN(String.valueOf("boolean"));


    String value;

    TypeEnum(String v) {
      value = v;
    }

    public String value() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static final class Deserializer implements JsonbDeserializer<TypeEnum> {
      @Override
      public TypeEnum deserialize(JsonParser parser, DeserializationContext ctx, Type rtType) {
        for (TypeEnum b : TypeEnum.values()) {
          if (String.valueOf(b.value).equals(parser.getString())) {
            return b;
          }
        }
        throw new IllegalArgumentException("Unexpected value '" + parser.getString() + "'");
      }
    }

    public static final class Serializer implements JsonbSerializer<TypeEnum> {
      @Override
      public void serialize(TypeEnum obj, JsonGenerator generator, SerializationContext ctx) {
        generator.write(obj.value);
      }
    }
  }

  /**
   * Data type, from JSON spec. Can be: - object - array - string - number - integer - boolean
   **/
  @JsonbProperty("type")
  private TypeEnum type;

  /**
   * Can the field process multiple values, HCL Domino style. When missing => false
   **/
  @JsonbProperty("multivalue")
  private Boolean multivalue;

  /**
   * Domino multi-value fields can be grouped together to form a kind oc child record in a document.
   * The fieldGroup defines such a grouping. It only is relevant for multi-value fields and isn't
   * populated by default
   **/
  @JsonbProperty("fieldGroup")
  private String fieldGroup;

  /**
   * Long text explanation what the field is about
   **/
  @JsonbProperty("description")
  private String description;

  @JsonbTypeSerializer(FormatEnum.Serializer.class)
  @JsonbTypeDeserializer(FormatEnum.Deserializer.class)
  public enum FormatEnum {

    AUTHORS(String.valueOf("authors")), BINARY(String.valueOf("binary")), BYTE(
        String.valueOf("byte")), DATE(String.valueOf("date")), DATE_TIME(String.valueOf(
            "date-time")), DOUBLE(String.valueOf("double")), FLOAT(String.valueOf("float")), INT32(
                String.valueOf("int32")), INT64(String.valueOf("int64")), NAMES(
                    String.valueOf("names")), PASSWORD(String.valueOf("password")), READERS(
                        String.valueOf("readers")), RICHTEXT(String.valueOf("richtext")), BOOLEAN(
                            String.valueOf("boolean")), STRING(String.valueOf("string")), JSON(
                                String.valueOf("json")), ATTACHMENTS(String.valueOf("attachments"));


    String value;

    FormatEnum(String v) {
      value = v;
    }

    public String value() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static final class Deserializer implements JsonbDeserializer<FormatEnum> {
      @Override
      public FormatEnum deserialize(JsonParser parser, DeserializationContext ctx, Type rtType) {
        for (FormatEnum b : FormatEnum.values()) {
          if (String.valueOf(b.value).equals(parser.getString())) {
            return b;
          }
        }
        throw new IllegalArgumentException("Unexpected value '" + parser.getString() + "'");
      }
    }

    public static final class Serializer implements JsonbSerializer<FormatEnum> {
      @Override
      public void serialize(FormatEnum obj, JsonGenerator generator, SerializationContext ctx) {
        generator.write(obj.value);
      }
    }
  }

  /**
   * Format definition for Strings, extended from json-schema with readers, authors, names, json
   **/
  @JsonbProperty("format")
  private FormatEnum format;

  /**
   * Item description can contain type and format
   **/
  @JsonbProperty("items")
  private Object items;

  /**
   * for array type: minimum number of items
   **/
  @JsonbProperty("minitems")
  private Integer minitems;

  /**
   * Shall array members be unique
   **/
  @JsonbProperty("uniqueitems")
  private Boolean uniqueitems;

  /**
   * lowest value, value included
   **/
  @JsonbProperty("minimum")
  private BigDecimal minimum;

  /**
   * maximum value, not included
   **/
  @JsonbProperty("maximum")
  private BigDecimal maximum;

  /**
   * Minimum value, not included
   **/
  @JsonbProperty("exclusiveMinimum")
  private BigDecimal exclusiveMinimum;

  /**
   * not longer than that
   **/
  @JsonbProperty("maxLength")
  private Integer maxLength;

  /**
   * Low long is a String
   **/
  @JsonbProperty("minLength")
  private Integer minLength;

  @JsonbTypeSerializer(FieldAccessEnum.Serializer.class)
  @JsonbTypeDeserializer(FieldAccessEnum.Deserializer.class)
  public enum FieldAccessEnum {

    RW(String.valueOf("RW")), RO(String.valueOf("RO")), WO(String.valueOf("WO"));


    String value;

    FieldAccessEnum(String v) {
      value = v;
    }

    public String value() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static final class Deserializer implements JsonbDeserializer<FieldAccessEnum> {
      @Override
      public FieldAccessEnum deserialize(JsonParser parser, DeserializationContext ctx,
          Type rtType) {
        for (FieldAccessEnum b : FieldAccessEnum.values()) {
          if (String.valueOf(b.value).equals(parser.getString())) {
            return b;
          }
        }
        throw new IllegalArgumentException("Unexpected value '" + parser.getString() + "'");
      }
    }

    public static final class Serializer implements JsonbSerializer<FieldAccessEnum> {
      @Override
      public void serialize(FieldAccessEnum obj, JsonGenerator generator,
          SerializationContext ctx) {
        generator.write(obj.value);
      }
    }
  }

  /**
   * Determines the access to a field as Read/Write, ReadOnly or WriteOnly
   **/
  @JsonbProperty("fieldAccess")
  private FieldAccessEnum fieldAccess;

  public KeepField() {}

  @JsonbCreator
  public KeepField(
      @JsonbProperty(value = "multivalue", nillable = true) Boolean multivalue) {
    this.multivalue = multivalue;
  }

  /**
   * Field name. While anything theoretical is possible we stick to letters and numbers with the
   * first letter capitalized. Not a hard rule to accomodate existing data
   * 
   * @return name
   **/
  @NotNull
  public String getName() {
    return name;
  }

  /**
   * Set name
   **/
  public void setName(String name) {
    this.name = name;
  }

  public KeepField name(String name) {
    this.name = name;
    return this;
  }

  /**
   * Data type, from JSON spec. Can be: - object - array - string - number - integer - boolean
   * 
   * @return type
   **/
  @NotNull
  public TypeEnum getType() {
    return type;
  }

  /**
   * Set type
   **/
  public void setType(TypeEnum type) {
    this.type = type;
  }

  public KeepField type(TypeEnum type) {
    this.type = type;
    return this;
  }

  /**
   * Can the field process multiple values, HCL Domino style. When missing &#x3D;&gt; false
   * 
   * @return multivalue
   **/
  public Boolean getMultivalue() {
    return multivalue;
  }


  /**
   * Domino multi-value fields can be grouped together to form a kind oc child record in a document.
   * The fieldGroup defines such a grouping. It only is relevant for multi-value fields and
   * isn&#39;t populated by default
   * 
   * @return fieldGroup
   **/
  public String getFieldGroup() {
    return fieldGroup;
  }

  /**
   * Set fieldGroup
   **/
  public void setFieldGroup(String fieldGroup) {
    this.fieldGroup = fieldGroup;
  }

  public KeepField fieldGroup(String fieldGroup) {
    this.fieldGroup = fieldGroup;
    return this;
  }

  /**
   * Long text explanation what the field is about
   * 
   * @return description
   **/
  public String getDescription() {
    return description;
  }

  /**
   * Set description
   **/
  public void setDescription(String description) {
    this.description = description;
  }

  public KeepField description(String description) {
    this.description = description;
    return this;
  }

  /**
   * Format definition for Strings, extended from json-schema with readers, authors, names, json
   * 
   * @return format
   **/
  public FormatEnum getFormat() {
    return format;
  }

  /**
   * Set format
   **/
  public void setFormat(FormatEnum format) {
    this.format = format;
  }

  public KeepField format(FormatEnum format) {
    this.format = format;
    return this;
  }

  /**
   * Item description can contain type and format
   * 
   * @return items
   **/
  public Object getItems() {
    return items;
  }

  /**
   * Set items
   **/
  public void setItems(Object items) {
    this.items = items;
  }

  public KeepField items(Object items) {
    this.items = items;
    return this;
  }

  /**
   * for array type: minimum number of items
   * 
   * @return minitems
   **/
  public Integer getMinitems() {
    return minitems;
  }

  /**
   * Set minitems
   **/
  public void setMinitems(Integer minitems) {
    this.minitems = minitems;
  }

  public KeepField minitems(Integer minitems) {
    this.minitems = minitems;
    return this;
  }

  /**
   * Shall array members be unique
   * 
   * @return uniqueitems
   **/
  public Boolean getUniqueitems() {
    return uniqueitems;
  }

  /**
   * Set uniqueitems
   **/
  public void setUniqueitems(Boolean uniqueitems) {
    this.uniqueitems = uniqueitems;
  }

  public KeepField uniqueitems(Boolean uniqueitems) {
    this.uniqueitems = uniqueitems;
    return this;
  }

  /**
   * lowest value, value included
   * 
   * @return minimum
   **/
  public BigDecimal getMinimum() {
    return minimum;
  }

  /**
   * Set minimum
   **/
  public void setMinimum(BigDecimal minimum) {
    this.minimum = minimum;
  }

  public KeepField minimum(BigDecimal minimum) {
    this.minimum = minimum;
    return this;
  }

  /**
   * maximum value, not included
   * 
   * @return maximum
   **/
  public BigDecimal getMaximum() {
    return maximum;
  }

  /**
   * Set maximum
   **/
  public void setMaximum(BigDecimal maximum) {
    this.maximum = maximum;
  }

  public KeepField maximum(BigDecimal maximum) {
    this.maximum = maximum;
    return this;
  }

  /**
   * Minimum value, not included
   * 
   * @return exclusiveMinimum
   **/
  public BigDecimal getExclusiveMinimum() {
    return exclusiveMinimum;
  }

  /**
   * Set exclusiveMinimum
   **/
  public void setExclusiveMinimum(BigDecimal exclusiveMinimum) {
    this.exclusiveMinimum = exclusiveMinimum;
  }

  public KeepField exclusiveMinimum(BigDecimal exclusiveMinimum) {
    this.exclusiveMinimum = exclusiveMinimum;
    return this;
  }

  /**
   * not longer than that
   * 
   * @return maxLength
   **/
  public Integer getMaxLength() {
    return maxLength;
  }

  /**
   * Set maxLength
   **/
  public void setMaxLength(Integer maxLength) {
    this.maxLength = maxLength;
  }

  public KeepField maxLength(Integer maxLength) {
    this.maxLength = maxLength;
    return this;
  }

  /**
   * Low long is a String
   * 
   * @return minLength
   **/
  public Integer getMinLength() {
    return minLength;
  }

  /**
   * Set minLength
   **/
  public void setMinLength(Integer minLength) {
    this.minLength = minLength;
  }

  public KeepField minLength(Integer minLength) {
    this.minLength = minLength;
    return this;
  }

  /**
   * Determines the access to a field as Read/Write, ReadOnly or WriteOnly
   * 
   * @return fieldAccess
   **/
  public FieldAccessEnum getFieldAccess() {
    return fieldAccess;
  }

  /**
   * Set fieldAccess
   **/
  public void setFieldAccess(FieldAccessEnum fieldAccess) {
    this.fieldAccess = fieldAccess;
  }

  public KeepField fieldAccess(FieldAccessEnum fieldAccess) {
    this.fieldAccess = fieldAccess;
    return this;
  }


  /**
   * Create a string representation of this pojo.
   **/
  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class KeepField {\n");

    sb.append("    name: ").append(toIndentedString(name)).append("\n");
    sb.append("    type: ").append(toIndentedString(type)).append("\n");
    sb.append("    multivalue: ").append(toIndentedString(multivalue)).append("\n");
    sb.append("    fieldGroup: ").append(toIndentedString(fieldGroup)).append("\n");
    sb.append("    description: ").append(toIndentedString(description)).append("\n");
    sb.append("    format: ").append(toIndentedString(format)).append("\n");
    sb.append("    items: ").append(toIndentedString(items)).append("\n");
    sb.append("    minitems: ").append(toIndentedString(minitems)).append("\n");
    sb.append("    uniqueitems: ").append(toIndentedString(uniqueitems)).append("\n");
    sb.append("    minimum: ").append(toIndentedString(minimum)).append("\n");
    sb.append("    maximum: ").append(toIndentedString(maximum)).append("\n");
    sb.append("    exclusiveMinimum: ").append(toIndentedString(exclusiveMinimum)).append("\n");
    sb.append("    maxLength: ").append(toIndentedString(maxLength)).append("\n");
    sb.append("    minLength: ").append(toIndentedString(minLength)).append("\n");
    sb.append("    fieldAccess: ").append(toIndentedString(fieldAccess)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private static String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }
}

