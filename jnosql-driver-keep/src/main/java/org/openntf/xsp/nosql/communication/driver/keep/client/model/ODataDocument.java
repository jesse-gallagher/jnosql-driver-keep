/**
 * HCL Project KEEP Core API v1
 * REST APIs for Domino and more done right. With declarative security and access to Code, Design and data
 *
 * The version of the OpenAPI document: 4.3.9
 * Contact: HeyHCL@pnp-hcl.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

package org.openntf.xsp.nosql.communication.driver.keep.client.model;

import java.time.OffsetDateTime;

import jakarta.json.bind.annotation.JsonbProperty;

/**
  * Definition for specified form or view of OData service document of a database.
 **/

public class ODataDocument  {
  
 /**
   * The ID of the OData entity.
  **/
  @JsonbProperty("@odata.id")
  private String atOdataId;

 /**
   * The link used to edit/update the entity,
  **/
  @JsonbProperty("@odata.editLink")
  private String atOdataEditLink;

 /**
   * Weak ETag of the current document
  **/
  @JsonbProperty("@odata.etag")
  private String atOdataEtag;

 /**
   * Primary key of a document, unique across NSF databases with matching replicaIds
  **/
  @JsonbProperty("_x0040_unid")
  private String x0040Unid;

 /**
   * Local (current NSF only) primary key of a document
  **/
  @JsonbProperty("_x0040_noteid")
  private Integer x0040Noteid;

 /**
   * Date of document creation in ISO format
  **/
  @JsonbProperty("_x0040_created")
  private OffsetDateTime x0040Created;

 /**
   * Last update date of a document
  **/
  @JsonbProperty("_x0040_lastmodified")
  private OffsetDateTime x0040Lastmodified;

 /**
   * This field records the current revision version of document. It's a 32-character hex-encoded string of date.   If db config \"requireRevisionToUpdate\" is enabled, then revision is required when update document and only update document when revision version is right.
  **/
  @JsonbProperty("_x0040_revision")
  private String x0040Revision;

 /**
   * Last access date of a document
  **/
  @JsonbProperty("_x0040_lastaccessed")
  private OffsetDateTime x0040Lastaccessed;

 /**
   * size in byte of a document
  **/
  @JsonbProperty("_x0040_size")
  private Integer x0040Size;

 /**
   * Is the document unread by the current user
  **/
  @JsonbProperty("_x0040_unread")
  private Boolean x0040Unread;

 /**
   * Form name of a document
  **/
  @JsonbProperty("Form")
  private String form;

 /**
   * The ID of the OData entity.
   * @return atOdataId
  **/
  public String getAtOdataId() {
    return atOdataId;
  }

  /**
    * Set atOdataId
  **/
  public void setAtOdataId(String atOdataId) {
    this.atOdataId = atOdataId;
  }

  public ODataDocument atOdataId(String atOdataId) {
    this.atOdataId = atOdataId;
    return this;
  }

 /**
   * The link used to edit/update the entity,
   * @return atOdataEditLink
  **/
  public String getAtOdataEditLink() {
    return atOdataEditLink;
  }

  /**
    * Set atOdataEditLink
  **/
  public void setAtOdataEditLink(String atOdataEditLink) {
    this.atOdataEditLink = atOdataEditLink;
  }

  public ODataDocument atOdataEditLink(String atOdataEditLink) {
    this.atOdataEditLink = atOdataEditLink;
    return this;
  }

 /**
   * Weak ETag of the current document
   * @return atOdataEtag
  **/
  public String getAtOdataEtag() {
    return atOdataEtag;
  }

  /**
    * Set atOdataEtag
  **/
  public void setAtOdataEtag(String atOdataEtag) {
    this.atOdataEtag = atOdataEtag;
  }

  public ODataDocument atOdataEtag(String atOdataEtag) {
    this.atOdataEtag = atOdataEtag;
    return this;
  }

 /**
   * Primary key of a document, unique across NSF databases with matching replicaIds
   * @return x0040Unid
  **/
  public String getX0040Unid() {
    return x0040Unid;
  }

  /**
    * Set x0040Unid
  **/
  public void setX0040Unid(String x0040Unid) {
    this.x0040Unid = x0040Unid;
  }

  public ODataDocument x0040Unid(String x0040Unid) {
    this.x0040Unid = x0040Unid;
    return this;
  }

 /**
   * Local (current NSF only) primary key of a document
   * @return x0040Noteid
  **/
  public Integer getX0040Noteid() {
    return x0040Noteid;
  }

  /**
    * Set x0040Noteid
  **/
  public void setX0040Noteid(Integer x0040Noteid) {
    this.x0040Noteid = x0040Noteid;
  }

  public ODataDocument x0040Noteid(Integer x0040Noteid) {
    this.x0040Noteid = x0040Noteid;
    return this;
  }

 /**
   * Date of document creation in ISO format
   * @return x0040Created
  **/
  public OffsetDateTime getX0040Created() {
    return x0040Created;
  }

  /**
    * Set x0040Created
  **/
  public void setX0040Created(OffsetDateTime x0040Created) {
    this.x0040Created = x0040Created;
  }

  public ODataDocument x0040Created(OffsetDateTime x0040Created) {
    this.x0040Created = x0040Created;
    return this;
  }

 /**
   * Last update date of a document
   * @return x0040Lastmodified
  **/
  public OffsetDateTime getX0040Lastmodified() {
    return x0040Lastmodified;
  }

  /**
    * Set x0040Lastmodified
  **/
  public void setX0040Lastmodified(OffsetDateTime x0040Lastmodified) {
    this.x0040Lastmodified = x0040Lastmodified;
  }

  public ODataDocument x0040Lastmodified(OffsetDateTime x0040Lastmodified) {
    this.x0040Lastmodified = x0040Lastmodified;
    return this;
  }

 /**
   * This field records the current revision version of document. It&#39;s a 32-character hex-encoded string of date.   If db config \&quot;requireRevisionToUpdate\&quot; is enabled, then revision is required when update document and only update document when revision version is right.
   * @return x0040Revision
  **/
  public String getX0040Revision() {
    return x0040Revision;
  }

  /**
    * Set x0040Revision
  **/
  public void setX0040Revision(String x0040Revision) {
    this.x0040Revision = x0040Revision;
  }

  public ODataDocument x0040Revision(String x0040Revision) {
    this.x0040Revision = x0040Revision;
    return this;
  }

 /**
   * Last access date of a document
   * @return x0040Lastaccessed
  **/
  public OffsetDateTime getX0040Lastaccessed() {
    return x0040Lastaccessed;
  }

  /**
    * Set x0040Lastaccessed
  **/
  public void setX0040Lastaccessed(OffsetDateTime x0040Lastaccessed) {
    this.x0040Lastaccessed = x0040Lastaccessed;
  }

  public ODataDocument x0040Lastaccessed(OffsetDateTime x0040Lastaccessed) {
    this.x0040Lastaccessed = x0040Lastaccessed;
    return this;
  }

 /**
   * size in byte of a document
   * @return x0040Size
  **/
  public Integer getX0040Size() {
    return x0040Size;
  }

  /**
    * Set x0040Size
  **/
  public void setX0040Size(Integer x0040Size) {
    this.x0040Size = x0040Size;
  }

  public ODataDocument x0040Size(Integer x0040Size) {
    this.x0040Size = x0040Size;
    return this;
  }

 /**
   * Is the document unread by the current user
   * @return x0040Unread
  **/
  public Boolean getX0040Unread() {
    return x0040Unread;
  }

  /**
    * Set x0040Unread
  **/
  public void setX0040Unread(Boolean x0040Unread) {
    this.x0040Unread = x0040Unread;
  }

  public ODataDocument x0040Unread(Boolean x0040Unread) {
    this.x0040Unread = x0040Unread;
    return this;
  }

 /**
   * Form name of a document
   * @return form
  **/
  public String getForm() {
    return form;
  }

  /**
    * Set form
  **/
  public void setForm(String form) {
    this.form = form;
  }

  public ODataDocument form(String form) {
    this.form = form;
    return this;
  }


  /**
    * Create a string representation of this pojo.
  **/
  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class ODataDocument {\n");
    
    sb.append("    atOdataId: ").append(toIndentedString(atOdataId)).append("\n");
    sb.append("    atOdataEditLink: ").append(toIndentedString(atOdataEditLink)).append("\n");
    sb.append("    atOdataEtag: ").append(toIndentedString(atOdataEtag)).append("\n");
    sb.append("    x0040Unid: ").append(toIndentedString(x0040Unid)).append("\n");
    sb.append("    x0040Noteid: ").append(toIndentedString(x0040Noteid)).append("\n");
    sb.append("    x0040Created: ").append(toIndentedString(x0040Created)).append("\n");
    sb.append("    x0040Lastmodified: ").append(toIndentedString(x0040Lastmodified)).append("\n");
    sb.append("    x0040Revision: ").append(toIndentedString(x0040Revision)).append("\n");
    sb.append("    x0040Lastaccessed: ").append(toIndentedString(x0040Lastaccessed)).append("\n");
    sb.append("    x0040Size: ").append(toIndentedString(x0040Size)).append("\n");
    sb.append("    x0040Unread: ").append(toIndentedString(x0040Unread)).append("\n");
    sb.append("    form: ").append(toIndentedString(form)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private static String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }
}

