/**
 * HCL Domino REST API basis
 * REST APIs for Domino and more done right. With declarative security and access to Code, Design and Data
 *
 * The version of the OpenAPI document: 1.0.10
 * Contact: HeyHCL@pnp-hcl.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

package org.openntf.xsp.nosql.communication.driver.keep.client.model;

import java.lang.reflect.Type;
import java.util.List;

import jakarta.json.bind.annotation.JsonbCreator;
import jakarta.json.bind.annotation.JsonbProperty;
import jakarta.json.bind.annotation.JsonbTypeDeserializer;
import jakarta.json.bind.annotation.JsonbTypeSerializer;
import jakarta.json.bind.serializer.DeserializationContext;
import jakarta.json.bind.serializer.JsonbDeserializer;
import jakarta.json.bind.serializer.JsonbSerializer;
import jakarta.json.bind.serializer.SerializationContext;
import jakarta.json.stream.JsonGenerator;
import jakarta.json.stream.JsonParser;
import jakarta.validation.constraints.NotNull;

/**
  * REST API Configuration of a domino database including views, forms, agents, modes. Used only for admin endpoints.
 **/

public class KeepDatabase  {
  
 /**
   * How this database is known to the API
  **/
  @JsonbProperty("apiName")
  private String apiName;

 /**
   * Description with human readable details of the database's purpose
  **/
  @JsonbProperty("description")
  private String description;

  @JsonbTypeSerializer(FormulaEngineEnum.Serializer.class)
  @JsonbTypeDeserializer(FormulaEngineEnum.Deserializer.class)
  public enum FormulaEngineEnum {

    DOMINO(String.valueOf("domino")), OPENFORMULA(String.valueOf("openformula")), JAVASCRIPT(String.valueOf("javascript"));


    String value;

    FormulaEngineEnum (String v) {
        value = v;
    }

    public String value() {
        return value;
    }

    @Override
    public String toString() {
        return String.valueOf(value);
    }

    public static final class Deserializer implements JsonbDeserializer<FormulaEngineEnum> {
        @Override
        public FormulaEngineEnum deserialize(JsonParser parser, DeserializationContext ctx, Type rtType) {
            for (FormulaEngineEnum b : FormulaEngineEnum.values()) {
                if (String.valueOf(b.value).equals(parser.getString())) {
                    return b;
                }
            }
            throw new IllegalArgumentException("Unexpected value '" + parser.getString() + "'");
        }
    }

    public static final class Serializer implements JsonbSerializer<FormulaEngineEnum> {
        @Override
        public void serialize(FormulaEngineEnum obj, JsonGenerator generator, SerializationContext ctx) {
            generator.write(obj.value);
        }
    }
  }

 /**
   * Script engine to be used to resolve permission formulas in FormModes or DQL access. Native Domino, OpenFormula or JavaScript  Currently only Native Domino is implemented
  **/
  @JsonbProperty("formulaEngine")
  private FormulaEngineEnum formulaEngine;

 /**
   * Base64 of an icon. SVG preferred
  **/
  @JsonbProperty("icon")
  private String icon;

 /**
   * alt text for icon
  **/
  @JsonbProperty("iconName")
  private String iconName;

 /**
   * Allows to enable/disable API access without removing cofiguration. This is used for scope. active is used for schema. 
  **/
  @JsonbProperty("isActive")
  private Boolean isActive;

 /**
   * List of agents that are permitted to be called from the API
  **/
  @JsonbProperty("agents")
  private List<AgentInfo> agents = null;

 /**
   * Can JS code be submitted for execution
  **/
  @JsonbProperty("allowCode")
  private Boolean allowCode;

 /**
   * All forms that are configured for access via the Domino REST API. Details in keepdatabaseconfig_formmode
  **/
  @JsonbProperty("configuredForms")
  private List<String> configuredForms = null;

 /**
   * Does the API allow DQL queries to be submitted? DQL can query any document. Handle with care
  **/
  @JsonbProperty("dqlAccess")
  private Boolean dqlAccess;

 /**
   * Array with form configurations including form modes
  **/
  @JsonbProperty("forms")
  private List<KeepForm> forms = null;

 /**
   * Can this database be accessed from a browser e.g. in a React app) or app without providing AppId and AppSecret. Still proper authentication using a JWT bearer is required
  **/
  @JsonbProperty("openAccess")
  private Boolean openAccess;

  @JsonbProperty("dqlFormula")
  private KeepFormula dqlFormula;

 /**
   * Collection of key / value pairs to map primary form names to potential alias values. A Notes document created with a form containing the alias will have the last alias value in its Form field
  **/
  @JsonbProperty("formAliases")
  private Object formAliases;

 /**
   * If db config \"requireRevisionToUpdate\" is enabled, then revision is required when update document and only update document when revision version is right.   
  **/
  @JsonbProperty("requireRevisionToUpdate")
  private Boolean requireRevisionToUpdate;

 /**
   * Array of Views that are available in the Domino REST API
  **/
  @JsonbProperty("views")
  private List<ViewInfo> views = null;

 /**
   * Location on Domino server
  **/
  @JsonbProperty("nsfPath")
  private String nsfPath;

 /**
   * name (without .json extension) of schema file in nsf REST file resources
  **/
  @JsonbProperty("schemaName")
  private String schemaName;

 /**
   * Allow decrypt the database
  **/
  @JsonbProperty("allowDecryption")
  private Boolean allowDecryption;

 /**
   * timestamp for when design data were last added
  **/
  @JsonbProperty("cacheTimestamp")
  private Integer cacheTimestamp;

 /**
   * Universal Id of the document to be acted upon
  **/
  @JsonbProperty("@unid")
  private String atUnid;

 /**
   * DXL path for this database
  **/
  @JsonbProperty("dxlpath")
  private String dxlpath;

 /**
   * Array of Views that are available in the Domino REST API
  **/
  @JsonbProperty("availableViews")
  private List<ViewInfo> availableViews = null;

 /**
   * indicates if the schema is protected against refresh by the design tast
  **/
  @JsonbProperty("prohibitRefresh")
  private Boolean prohibitRefresh;

  public KeepDatabase() {
  }

  @JsonbCreator
  public KeepDatabase(
    @JsonbProperty(value = "@unid", nillable = true) String atUnid, 
    @JsonbProperty(value = "dxlpath", nillable = true) String dxlpath
  ) {
    this.atUnid = atUnid;
    this.dxlpath = dxlpath;
  }
  
 /**
   * How this database is known to the API
   * @return apiName
  **/
  public String getApiName() {
    return apiName;
  }

  /**
    * Set apiName
  **/
  public void setApiName(String apiName) {
    this.apiName = apiName;
  }

  public KeepDatabase apiName(String apiName) {
    this.apiName = apiName;
    return this;
  }

 /**
   * Description with human readable details of the database&#39;s purpose
   * @return description
  **/
  public String getDescription() {
    return description;
  }

  /**
    * Set description
  **/
  public void setDescription(String description) {
    this.description = description;
  }

  public KeepDatabase description(String description) {
    this.description = description;
    return this;
  }

 /**
   * Script engine to be used to resolve permission formulas in FormModes or DQL access. Native Domino, OpenFormula or JavaScript  Currently only Native Domino is implemented
   * @return formulaEngine
  **/
  @NotNull
  public FormulaEngineEnum getFormulaEngine() {
    return formulaEngine;
  }

  /**
    * Set formulaEngine
  **/
  public void setFormulaEngine(FormulaEngineEnum formulaEngine) {
    this.formulaEngine = formulaEngine;
  }

  public KeepDatabase formulaEngine(FormulaEngineEnum formulaEngine) {
    this.formulaEngine = formulaEngine;
    return this;
  }

 /**
   * Base64 of an icon. SVG preferred
   * @return icon
  **/
  public String getIcon() {
    return icon;
  }

  /**
    * Set icon
  **/
  public void setIcon(String icon) {
    this.icon = icon;
  }

  public KeepDatabase icon(String icon) {
    this.icon = icon;
    return this;
  }

 /**
   * alt text for icon
   * @return iconName
  **/
  public String getIconName() {
    return iconName;
  }

  /**
    * Set iconName
  **/
  public void setIconName(String iconName) {
    this.iconName = iconName;
  }

  public KeepDatabase iconName(String iconName) {
    this.iconName = iconName;
    return this;
  }

 /**
   * Allows to enable/disable API access without removing cofiguration. This is used for scope. active is used for schema. 
   * @return isActive
  **/
  @NotNull
  public Boolean getIsActive() {
    return isActive;
  }

  /**
    * Set isActive
  **/
  public void setIsActive(Boolean isActive) {
    this.isActive = isActive;
  }

  public KeepDatabase isActive(Boolean isActive) {
    this.isActive = isActive;
    return this;
  }

 /**
   * List of agents that are permitted to be called from the API
   * @return agents
  **/
  public List<AgentInfo> getAgents() {
    return agents;
  }

  /**
    * Set agents
  **/
  public void setAgents(List<AgentInfo> agents) {
    this.agents = agents;
  }

  public KeepDatabase agents(List<AgentInfo> agents) {
    this.agents = agents;
    return this;
  }

  public KeepDatabase addAgentsItem(AgentInfo agentsItem) {
    this.agents.add(agentsItem);
    return this;
  }

 /**
   * Can JS code be submitted for execution
   * @return allowCode
  **/
  public Boolean getAllowCode() {
    return allowCode;
  }

  /**
    * Set allowCode
  **/
  public void setAllowCode(Boolean allowCode) {
    this.allowCode = allowCode;
  }

  public KeepDatabase allowCode(Boolean allowCode) {
    this.allowCode = allowCode;
    return this;
  }

 /**
   * All forms that are configured for access via the Domino REST API. Details in keepdatabaseconfig_formmode
   * @return configuredForms
  **/
  public List<String> getConfiguredForms() {
    return configuredForms;
  }

  /**
    * Set configuredForms
  **/
  public void setConfiguredForms(List<String> configuredForms) {
    this.configuredForms = configuredForms;
  }

  public KeepDatabase configuredForms(List<String> configuredForms) {
    this.configuredForms = configuredForms;
    return this;
  }

  public KeepDatabase addConfiguredFormsItem(String configuredFormsItem) {
    this.configuredForms.add(configuredFormsItem);
    return this;
  }

 /**
   * Does the API allow DQL queries to be submitted? DQL can query any document. Handle with care
   * @return dqlAccess
  **/
  public Boolean getDqlAccess() {
    return dqlAccess;
  }

  /**
    * Set dqlAccess
  **/
  public void setDqlAccess(Boolean dqlAccess) {
    this.dqlAccess = dqlAccess;
  }

  public KeepDatabase dqlAccess(Boolean dqlAccess) {
    this.dqlAccess = dqlAccess;
    return this;
  }

 /**
   * Array with form configurations including form modes
   * @return forms
  **/
  public List<KeepForm> getForms() {
    return forms;
  }

  /**
    * Set forms
  **/
  public void setForms(List<KeepForm> forms) {
    this.forms = forms;
  }

  public KeepDatabase forms(List<KeepForm> forms) {
    this.forms = forms;
    return this;
  }

  public KeepDatabase addFormsItem(KeepForm formsItem) {
    this.forms.add(formsItem);
    return this;
  }

 /**
   * Can this database be accessed from a browser e.g. in a React app) or app without providing AppId and AppSecret. Still proper authentication using a JWT bearer is required
   * @return openAccess
  **/
  public Boolean getOpenAccess() {
    return openAccess;
  }

  /**
    * Set openAccess
  **/
  public void setOpenAccess(Boolean openAccess) {
    this.openAccess = openAccess;
  }

  public KeepDatabase openAccess(Boolean openAccess) {
    this.openAccess = openAccess;
    return this;
  }

 /**
   * Get dqlFormula
   * @return dqlFormula
  **/
  public KeepFormula getDqlFormula() {
    return dqlFormula;
  }

  /**
    * Set dqlFormula
  **/
  public void setDqlFormula(KeepFormula dqlFormula) {
    this.dqlFormula = dqlFormula;
  }

  public KeepDatabase dqlFormula(KeepFormula dqlFormula) {
    this.dqlFormula = dqlFormula;
    return this;
  }

 /**
   * Collection of key / value pairs to map primary form names to potential alias values. A Notes document created with a form containing the alias will have the last alias value in its Form field
   * @return formAliases
  **/
  public Object getFormAliases() {
    return formAliases;
  }

  /**
    * Set formAliases
  **/
  public void setFormAliases(Object formAliases) {
    this.formAliases = formAliases;
  }

  public KeepDatabase formAliases(Object formAliases) {
    this.formAliases = formAliases;
    return this;
  }

 /**
   * If db config \&quot;requireRevisionToUpdate\&quot; is enabled, then revision is required when update document and only update document when revision version is right.   
   * @return requireRevisionToUpdate
  **/
  public Boolean getRequireRevisionToUpdate() {
    return requireRevisionToUpdate;
  }

  /**
    * Set requireRevisionToUpdate
  **/
  public void setRequireRevisionToUpdate(Boolean requireRevisionToUpdate) {
    this.requireRevisionToUpdate = requireRevisionToUpdate;
  }

  public KeepDatabase requireRevisionToUpdate(Boolean requireRevisionToUpdate) {
    this.requireRevisionToUpdate = requireRevisionToUpdate;
    return this;
  }

 /**
   * Array of Views that are available in the Domino REST API
   * @return views
  **/
  public List<ViewInfo> getViews() {
    return views;
  }

  /**
    * Set views
  **/
  public void setViews(List<ViewInfo> views) {
    this.views = views;
  }

  public KeepDatabase views(List<ViewInfo> views) {
    this.views = views;
    return this;
  }

  public KeepDatabase addViewsItem(ViewInfo viewsItem) {
    this.views.add(viewsItem);
    return this;
  }

 /**
   * Location on Domino server
   * @return nsfPath
  **/
  @NotNull
  public String getNsfPath() {
    return nsfPath;
  }

  /**
    * Set nsfPath
  **/
  public void setNsfPath(String nsfPath) {
    this.nsfPath = nsfPath;
  }

  public KeepDatabase nsfPath(String nsfPath) {
    this.nsfPath = nsfPath;
    return this;
  }

 /**
   * name (without .json extension) of schema file in nsf REST file resources
   * @return schemaName
  **/
  public String getSchemaName() {
    return schemaName;
  }

  /**
    * Set schemaName
  **/
  public void setSchemaName(String schemaName) {
    this.schemaName = schemaName;
  }

  public KeepDatabase schemaName(String schemaName) {
    this.schemaName = schemaName;
    return this;
  }

 /**
   * Allow decrypt the database
   * @return allowDecryption
  **/
  public Boolean getAllowDecryption() {
    return allowDecryption;
  }

  /**
    * Set allowDecryption
  **/
  public void setAllowDecryption(Boolean allowDecryption) {
    this.allowDecryption = allowDecryption;
  }

  public KeepDatabase allowDecryption(Boolean allowDecryption) {
    this.allowDecryption = allowDecryption;
    return this;
  }

 /**
   * timestamp for when design data were last added
   * @return cacheTimestamp
  **/
  public Integer getCacheTimestamp() {
    return cacheTimestamp;
  }

  /**
    * Set cacheTimestamp
  **/
  public void setCacheTimestamp(Integer cacheTimestamp) {
    this.cacheTimestamp = cacheTimestamp;
  }

  public KeepDatabase cacheTimestamp(Integer cacheTimestamp) {
    this.cacheTimestamp = cacheTimestamp;
    return this;
  }

 /**
   * Universal Id of the document to be acted upon
   * @return atUnid
  **/
  public String getAtUnid() {
    return atUnid;
  }


 /**
   * DXL path for this database
   * @return dxlpath
  **/
  public String getDxlpath() {
    return dxlpath;
  }


 /**
   * Array of Views that are available in the Domino REST API
   * @return availableViews
  **/
  public List<ViewInfo> getAvailableViews() {
    return availableViews;
  }

  /**
    * Set availableViews
  **/
  public void setAvailableViews(List<ViewInfo> availableViews) {
    this.availableViews = availableViews;
  }

  public KeepDatabase availableViews(List<ViewInfo> availableViews) {
    this.availableViews = availableViews;
    return this;
  }

  public KeepDatabase addAvailableViewsItem(ViewInfo availableViewsItem) {
    this.availableViews.add(availableViewsItem);
    return this;
  }

 /**
   * indicates if the schema is protected against refresh by the design tast
   * @return prohibitRefresh
  **/
  public Boolean getProhibitRefresh() {
    return prohibitRefresh;
  }

  /**
    * Set prohibitRefresh
  **/
  public void setProhibitRefresh(Boolean prohibitRefresh) {
    this.prohibitRefresh = prohibitRefresh;
  }

  public KeepDatabase prohibitRefresh(Boolean prohibitRefresh) {
    this.prohibitRefresh = prohibitRefresh;
    return this;
  }


  /**
    * Create a string representation of this pojo.
  **/
  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class KeepDatabase {\n");
    
    sb.append("    apiName: ").append(toIndentedString(apiName)).append("\n");
    sb.append("    description: ").append(toIndentedString(description)).append("\n");
    sb.append("    formulaEngine: ").append(toIndentedString(formulaEngine)).append("\n");
    sb.append("    icon: ").append(toIndentedString(icon)).append("\n");
    sb.append("    iconName: ").append(toIndentedString(iconName)).append("\n");
    sb.append("    isActive: ").append(toIndentedString(isActive)).append("\n");
    sb.append("    agents: ").append(toIndentedString(agents)).append("\n");
    sb.append("    allowCode: ").append(toIndentedString(allowCode)).append("\n");
    sb.append("    configuredForms: ").append(toIndentedString(configuredForms)).append("\n");
    sb.append("    dqlAccess: ").append(toIndentedString(dqlAccess)).append("\n");
    sb.append("    forms: ").append(toIndentedString(forms)).append("\n");
    sb.append("    openAccess: ").append(toIndentedString(openAccess)).append("\n");
    sb.append("    dqlFormula: ").append(toIndentedString(dqlFormula)).append("\n");
    sb.append("    formAliases: ").append(toIndentedString(formAliases)).append("\n");
    sb.append("    requireRevisionToUpdate: ").append(toIndentedString(requireRevisionToUpdate)).append("\n");
    sb.append("    views: ").append(toIndentedString(views)).append("\n");
    sb.append("    nsfPath: ").append(toIndentedString(nsfPath)).append("\n");
    sb.append("    schemaName: ").append(toIndentedString(schemaName)).append("\n");
    sb.append("    allowDecryption: ").append(toIndentedString(allowDecryption)).append("\n");
    sb.append("    cacheTimestamp: ").append(toIndentedString(cacheTimestamp)).append("\n");
    sb.append("    atUnid: ").append(toIndentedString(atUnid)).append("\n");
    sb.append("    dxlpath: ").append(toIndentedString(dxlpath)).append("\n");
    sb.append("    availableViews: ").append(toIndentedString(availableViews)).append("\n");
    sb.append("    prohibitRefresh: ").append(toIndentedString(prohibitRefresh)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private static String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }
}

